# Claude Code自律開発システム 詳細ガイド

このガイドでは、Claude Codeを使った自律開発システムの詳細な使い方とベストプラクティスを説明します。

## 目次

- [概要](#概要)
- [システムアーキテクチャ](#システムアーキテクチャ)
- [タスクファイルの書き方](#タスクファイルの書き方)
- [ベストプラクティス](#ベストプラクティス)
- [実例集](#実例集)
- [トラブルシューティング](#トラブルシューティング)

---

## 概要

Claude Code自律開発システムは、以下の特徴を持ちます:

- **完全自律** - 数時間のタスクを無人で実行
- **自動承認** - 全ツールの使用を自動承認
- **柔軟なコミット** - タスクごと、完了時、手動の選択可能
- **バックグラウンド実行** - 寝ている間に開発

### どんな時に使うか

✅ **適している用途:**
- 夜間の長時間開発
- ルーティン的な実装タスク
- 既存コードベースへの機能追加
- テストコード作成
- リファクタリング

❌ **適していない用途:**
- 重要な判断が必要なアーキテクチャ設計
- セキュリティに関わる実装
- 本番環境への直接デプロイ
- 不明瞭な要件のタスク

---

## システムアーキテクチャ

### ファイル構成

```
project/
├── auto-dev.sh                 # 基本実行スクリプト
├── auto-dev-with-commits.sh    # コミット付き実行
├── auto-dev-incremental.sh     # インクリメンタルコミット
├── run-overnight.sh            # バックグラウンド実行
├── .claude/
│   └── settings.local.json     # 自動承認設定
├── tonight.txt                 # タスクファイル（gitignore推奨）
└── nohup.out                   # 実行ログ（バックグラウンド時）
```

### 実行フロー

```
1. タスクファイル読み込み
   ↓
2. Claude Codeに渡す（claude -p）
   ↓
3. 自動承認設定により中断なし実行
   ↓
4. タスク完了
   ↓
5. （オプション）git commit
```

### 自動承認の仕組み

`.claude/settings.local.json`:

```json
{
  "permissions": {
    "allow": ["Bash", "Read", "Write", "Edit", "Glob", "Grep"],
    "deny": [],
    "ask": []
  }
}
```

- `allow`: 自動承認するツール
- `deny`: 自動拒否するツール
- `ask`: 確認が必要なツール

---

## タスクファイルの書き方

### 基本原則

1. **明確性** - 何を作るか明確に記述
2. **具体性** - 技術スタック、ファイル名を具体的に
3. **制約** - やって欲しくないことも明記
4. **検証可能** - 完了条件を明確に

### テンプレート

#### シンプル版

```markdown
今夜のタスク: [タスク名]

## 要件
- 要件1
- 要件2
- 要件3

## 技術スタック
- 言語/フレームワーク
- ライブラリ

## 制約
- やらないこと
- 注意点
```

#### 詳細版

```markdown
今夜のタスク: [タスク名]

## 背景
このタスクの背景や目的を説明

## 要件
### 機能要件
- 機能1: 詳細
- 機能2: 詳細

### 非機能要件
- パフォーマンス
- セキュリティ
- テストカバレッジ

## 技術スタック
- 言語: Go 1.21
- フレームワーク: chi
- データベース: PostgreSQL
- テスト: testify

## 実装ガイドライン
- ファイル構成
- 命名規則
- コーディングスタイル

## 制約
- 既存のコードを変更しない
- 外部APIは使用しない

## 完了条件
- [ ] 全テストが通る
- [ ] カバレッジ80%以上
- [ ] ビルドエラーなし
```

#### インクリメンタル版

```markdown
# タスク1: [タスク名]

[詳細説明]

完了したら以下のメッセージでコミット:
"[コミットメッセージ]"

---

# タスク2: [タスク名]

[詳細説明]

完了したらコミット:
"[コミットメッセージ]"
```

---

## ベストプラクティス

### 1. タスクの粒度

**適切な粒度:**
```markdown
# タスク1: データベーススキーマ設計
usersテーブルとpostsテーブルを作成

# タスク2: User モデル実装
CRUDメソッドを持つUserモデルを実装

# タスク3: User APIエンドポイント実装
RESTful APIエンドポイントを実装
```

**粒度が細かすぎる:**
```markdown
# タスク1: usersテーブル作成
# タスク2: postsテーブル作成
# タスク3: User構造体定義
# タスク4: GetUser関数実装
# タスク5: CreateUser関数実装
...
```

**粒度が粗すぎる:**
```markdown
# タスク1: Webアプリケーション全体を実装
データベース、API、フロントエンド、デプロイまで全て
```

### 2. 既存コードとの統合

```markdown
今夜のタスク: 既存プロジェクトに認証機能追加

## 既存コードの場所
- ルーティング: `cmd/server/routes.go`
- ミドルウェア: `internal/middleware/`
- 設定: `.env.example`

## 統合方法
- 既存のミドルウェアパターンに従う
- `internal/auth/` ディレクトリに実装
- 既存のエラーハンドリングを使用

## 変更してはいけないファイル
- `cmd/server/main.go` の構造
- `internal/database/` パッケージ
```

### 3. テストの指示

```markdown
## テスト要件
- ユニットテスト必須
- テストカバレッジ80%以上
- テーブル駆動テストを使用

## テストファイル配置
- `*_test.go` という命名規則
- テスト対象ファイルと同じディレクトリ

## テスト実行確認
タスク完了前に以下を実行:
- `go test ./...`
- `go test ./... -cover`
```

### 4. エラーハンドリング

```markdown
## エラーハンドリング方針
- すべてのエラーを適切にハンドリング
- ログにエラー詳細を記録
- ユーザーには分かりやすいメッセージ
- panic は使用しない
```

### 5. ドキュメント

```markdown
## ドキュメント要件
- 各パブリック関数にGoDocコメント
- README.md の Usage セクションを更新
- 新しいAPIエンドポイントをAPI.mdに追加

## ドキュメント不要
- プライベート関数
- テストコード
```

---

## 実例集

### 例1: RESTful APIサーバー

```markdown
今夜のタスク: ユーザー管理RESTful APIサーバー実装

## 要件
- CRUD操作（Create, Read, Update, Delete）
- JWT認証
- バリデーション
- エラーハンドリング
- テストカバレッジ80%以上

## 技術スタック
- Go 1.21
- chi router (github.com/go-chi/chi/v5)
- PostgreSQL
- golang-jwt/jwt
- testify

## API仕様
### エンドポイント
- POST /api/users - ユーザー作成
- GET /api/users/:id - ユーザー取得
- PUT /api/users/:id - ユーザー更新
- DELETE /api/users/:id - ユーザー削除
- POST /api/login - ログイン

### レスポンス形式
JSON形式、統一されたエラーレスポンス

## ファイル構成
```
cmd/
  server/
    main.go
internal/
  api/
    handlers.go
    handlers_test.go
  auth/
    jwt.go
    jwt_test.go
  models/
    user.go
  database/
    db.go
```

## 制約
- ORMは使用しない（database/sql を使用）
- フロントエンドは不要
- デプロイ設定は不要

## 完了条件
- [ ] 全テストが通る
- [ ] `go build` が成功
- [ ] カバレッジ80%以上
- [ ] `golangci-lint run` でエラーなし
```

### 例2: CLIツール拡張

```markdown
# タスク1: サブコマンド追加

既存のCLIツールに `export` サブコマンドを追加。

## 既存構成
- cobra を使用
- `cmd/root.go` にルートコマンド
- `cmd/analyze.go` に既存のanalyzeコマンド

## 実装内容
- `cmd/export.go` を新規作成
- JSON, CSV, YAML 形式でエクスポート
- `--format` フラグで形式選択
- `--output` フラグで出力先指定

## 使用例
```
mytool export --format=json --output=data.json
mytool export --format=csv --output=data.csv
```

完了したらコミット: "feat: exportサブコマンド追加"

---

# タスク2: テスト追加

exportコマンドのテストを追加。

## テスト内容
- 各フォーマットの出力テスト
- ファイル出力テスト
- エラーケーステスト

完了したらコミット: "test: exportコマンドのテスト追加"
```

### 例3: バグ修正

```markdown
今夜のタスク: Issue #123 のバグ修正

## バグ内容
`/api/users` エンドポイントでページネーションが動作しない

## 原因
SQLクエリのLIMIT/OFFSETが正しく適用されていない

## 修正箇所
- `internal/database/queries.go` の GetUsers関数
- クエリパラメータのパース処理

## テスト
- ページネーションのテストケース追加
- 境界値テスト（limit=0, offset=0）
- 無効なパラメータのテスト

## 完了条件
- [ ] バグが修正されている
- [ ] 既存テストが全て通る
- [ ] 新しいテストケース追加
- [ ] ドキュメント更新（必要な場合）
```

### 例4: リファクタリング

```markdown
今夜のタスク: エラーハンドリングのリファクタリング

## 背景
現在、エラーハンドリングが統一されておらず、コードが読みにくい

## 目標
- 統一されたエラー型の導入
- カスタムエラーの定義
- エラーラッピングの一貫性

## 実装
1. `internal/errors/errors.go` を作成
2. カスタムエラー型定義
3. 既存コードを新しいエラー処理に移行

## 対象ファイル
- `internal/api/*.go`
- `internal/database/*.go`
- `internal/auth/*.go`

## 制約
- 既存の動作を変更しない
- テストは全て通る必要がある
- 段階的にリファクタリング（一気にやらない）

## 完了条件
- [ ] 新しいエラー型が定義されている
- [ ] 主要な箇所がリファクタリングされている
- [ ] 全テストが通る
- [ ] ドキュメント更新
```

---

## トラブルシューティング

### タスクが途中で止まる

**原因:**
- インタラクティブな入力待ち
- 承認待ち

**解決策:**
```bash
# .claude/settings.local.json を確認
cat .claude/settings.local.json

# 必要なツールが allow に含まれているか確認
```

### コミットが作成されない

**原因:**
- タスクファイルにコミット指示がない
- git の設定不足

**解決策:**
```bash
# git 設定確認
git config user.name
git config user.email

# 設定されていない場合
git config --global user.name "Your Name"
git config --global user.email "your@email.com"
```

### エラーで失敗する

**原因:**
- ビルドエラー
- テスト失敗
- 依存関係不足

**解決策:**
```bash
# ログ確認
tail -100 nohup.out

# エラーメッセージで検索
grep ERROR nohup.out

# タスクファイルに事前チェックを追加
```

### 予期しない変更

**原因:**
- タスク指示が曖昧
- 制約が不足

**解決策:**
```markdown
## やってはいけないこと
- main.go の構造変更
- 既存のテストの削除
- 外部APIの追加
- 依存関係の追加（事前承認なし）

## 変更してよいファイル
- internal/api/ 配下
- cmd/server/ 配下（main.go以外）
```

---

## 高度な使い方

### 1. 条件付きタスク

```markdown
今夜のタスク: パフォーマンス最適化

## 手順
1. ベンチマークテストを実行
2. ボトルネックを特定
3. 最適化が必要であれば実装
4. ベンチマーク結果を比較

## 条件
- 改善が10%未満なら最適化不要
- 改善が10%以上なら実装
```

### 2. 複数プロジェクトの同時開発

```bash
# project-A
cd /path/to/project-A
./run-overnight.sh tonight-A.txt &

# project-B
cd /path/to/project-B
./run-overnight.sh tonight-B.txt &

# ログ監視
tail -f /path/to/project-A/nohup.out
tail -f /path/to/project-B/nohup.out
```

### 3. 定期実行

```bash
# cron で毎晩実行
crontab -e

# 毎晩23時に実行
0 23 * * * cd /path/to/project && ./run-overnight.sh tonight.txt
```

---

## まとめ

### 成功のポイント

1. **明確なタスク定義** - 曖昧さを排除
2. **適切な粒度** - 大きすぎず小さすぎず
3. **テストの徹底** - 完了条件にテスト含める
4. **制約の明示** - やって欲しくないことも書く
5. **ログ確認** - 定期的に進捗確認

### 次のステップ

- [使用方法](USAGE.md) - コマンドリファレンス
- [インストールガイド](INSTALL.md) - セットアップ方法
- [テストガイド](TESTING.md) - テストの実行方法
